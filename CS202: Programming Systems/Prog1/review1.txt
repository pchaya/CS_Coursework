Prathyoosha Chaya, CS202, Prof. Karla Fant
04/25/2017
EFFICIENCY WRITE-UP 1:

The overlying abstract data type used in this program was a graph. In this scenario, a graph ADT is definitely the right choice to make in creating the maze in use – as it is the most efficient way to make a data structure with so many interconnected pieces of data, when compared to a regular tree or table. The adjacency list creates a situation where there can potentially be "holes' in the data for the vertices (individual cheeckpoints), making this an "absolute list" of sorts. As the maze can have "holes" in between checkpoints, and if a checkpoint(location name and pointer to head of edge list) is removed from the tree or added, it is not relative to other nodes, and they should not shift around to accomodate in any way. The location of the vertex in the array is crucial to maintain the order of the graph, as if the vertex locations change, then the edge list pointers to these vertices would also have to change. The underlying data structures used were a class checkpoint type to create the vertex classification along with the node class. The node class has an instance within the checkpoint class, as each seperate checkpoint will have it's own "head" pointer to a list of other checkpoints that it is connected to. A new checkpoint is inserted into the adjacency list in a way that could be potentially more efficient. Currently, the insert checkpoint program loops through the adjacency list, adding connections and checkpoints until the chosen number of checkpoints has been reached. It then proceeds to add the data into that slot by calling a "set checkpoint" data function. These connections are shown through a doubly linked list, where each node has the pointer to a vertex, along with a node-type pointer to the next connection, which acts as the edge. Conceptually, the idea of having the underlying data form seperate classes made sense. The data types could be easily grouped together and is easily accessible by the node class. By having the checkpoint data and node as separate classes, the construction and destruction of these objects could be neatly managed. 

In this program, there were classes made to perform the job of each main component that the Maze game involved, such as the checkpoint, maze, player, list, friend list, and reward list classes. The hierarchical relationships were that a reward list "is a" list, and a friend list "is a" list as well. This means that they have the functionality of List, with a more specialized job of managing the rewards or friends, respectively. The responsibilities of the classes were not extended to other classes, for example when the checkpoint data needs to be set, there is a function to set this data within the checkpoint class, so that other classes are not trying to access or get this data in order to use or change it. In a larger application, the same hierarchical relationships would work, however the data structures used within may have to be modified to work more efficiently in a larger system.

GDB was used here to ensure that run-time segmentation faults or memory leaks would not take place, and that items were destructed properly. Breakpoints were placed along various points in the program, and the Next and Step commands were used to execute the next line of code and enter function calls. When a segmentation fault was found, I ran the program again through GDB and searched the backtrace when the segmentation fault occured, to see where in the call stack the segmentation fault had occured. In order to detect any memory leaks, valgrind was used to check if there were any memory losses.

If I had more time, I would like to try exploring how to write the data for the graph into a file to effectively save the data, which would be a challenge to implement and register all of the proper connections. I would also like to see what other implementations of a graph can be used besides an adjacency list, and potentially add other functionality, such as adding more rewards, allowing for more players, and condensing the classes further through a more effective OO design.