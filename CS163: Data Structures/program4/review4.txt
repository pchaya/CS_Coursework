Prathyoosha Chaya, CS 163 DATA STRUCTURES, Prof. Karla Fant
Efficiency Review 4
The overlying abstract data type used in this program was a binary search tree. In this scenario, a tree ADT is definitely the right choice to make in creating the dictionary in of CS terms in use here – as the dictionary should not have any "holes" in the data, and if an entry (CS term name and definition) is removed from the tree or added, it is relative to other nodes, and they should shift around it. The underlying data structures used were a struct entry type to create the data classification within the node and to allow the application to have its own user-filled dictionary entry to communicate to the ADT, as well as a struct node type. Conceptually, the idea of having the underlying data form structures made sense. The data types could be easily grouped together and is easily accessible by the node class. By having the entry data and node as separate classes, the construction and destruction of these objects could be neatly managed.
To store the data about the CS term dictionary the load function was used to first used to insert all of the data into the tree. Depending on the first data item in the file, the BST could end up being either completely linear (O(N), if the data is already sorted in the text file), or very efficient (if the data starts off with a middle term and subsequent data is balanced), with an efficiency of O(log2N). In order to avoid this issue, a balanced tree implementation could have been used, such as a 2-3 tree, AVL, 2-3-4, etc in order to avoid the unbalanced resulting binary search tree. By using a balanced tree ADT, the data will be inserted into the tree while shifting other entries to ensure that the tree remains balanced. The unbalanced tree that resulted in this program was proven by the "is efficient" function, where the height of the left subtree and the height of the right subtree were subtracted from each other. If this value was > 1 or < -1, then this proves that the binary search tree was unbalanced, which was what the function would repeatedly return.
The process of displaying all of the nodes did not require any extra traversals. Pre-order traversal was used to make sure that the data was outputed in sorted order, alphabetically (as a dictionary would be sorted). This did not create any efficiency loss, because only one traversal was made, and the right subtrees for all of the left nodes up until the "smallest" value would be displayed upon the backtrace. Adding and removing a cs term is O(log2N) in the case that this tree is balanced, but in most cases it is somewhere between O(log2N) and O(N), depending on how balanced the tree is. The use of  the tree is very efficient when compared to using a linear linked list or other type of linked list because of the lack of regular traversals for all search cases that have to be done in sorted order (insert and remove), however it does have a limitation that the data in a leaf is still not found in the most efficient way possible with a tree. 
If I had more time, I would like to try exploring how to implement a similar design with different tree data structures, especially experimenting with a balanced tree to see how the efficiency could be improved when it is balanced. Currently with a binary search tree in this program, the only way to attempt to make the tree to be sorted in a "more efficient way" was to change around the order of the data items in the text file. 