Prathyoosha Chaya, CS202, Prof. Karla Fant
05/12/2017
EFFICIENCY WRITE-UP 2:

The overlying abstract data type used in this program was a Binary Search tree (BST) and a circular linked list (CLL). In this scenario, a BST ADT is definitely the right choice to make in creating the address book in use – as it is the most efficient way to sort a lisk of people by their last name, and to be able to retrieve/find each person based on their last name. The tree allows for no "holes' in the data for the nodes (collection of people with the same last name), making this an "absolute list" of sorts. If a person is removed from the address book, or if they are added, they are relative to other nodes, and they should shift around to accomodate this new node. The underlying data structures used were various classes to manage the nodes within the CLL and BST, along with classes to provide functionality. The data types could be easily grouped together and is easily accessible by the node class. By having the checkpoint data and node as separate classes, the construction and destruction of these objects could be neatly managed. A different data structure could potentially be used, such as a linked list to manage the addressbook or a balanced tree. A linked list would prove to be extremely inefficient in terms of run-time, but a balanced tree would make the run-time more efficient than the current BST implemetation. Conceptually, the idea of having the underlying data form seperate classes made sense. In terms of efficiency of the data struucture, the process of displaying all of the nodes did not require any extra traversals. Pre-order traversal was used to make sure that the data was outputed in sorted order, alphabetically by last name. This did not create any efficiency loss, because only one traversal was made, and the right subtrees for all of the left nodes up until the "smallest" name would be displayed upon the backtrace. Adding and removing a Person into the addressbook is O(log2N) in the case that this tree is balanced, which is highly unlikely unless if the tester enters names in a specific order to ensure that the tree is balanced. In most cases it is somewhere between O(log2N) and O(N), depending on how balanced the tree is. 

Compared to program 1, this program had each class have a more distinct responsibility. There were classes made to perform the job of each main component, such as the abstract base class: Comm, and all of its derived classes: US_mail, Email, Text, and Twitter. The hierarchical relationships were that these derived classes were all children of the abstract base class Comm. This means that they have the functionality of Comm, but Comm  itself cannot be instantiated. To access the Comm methods, I had to upcast the pointer to the derived class. The elements with similar functionality were in the common base class, such as the communication type and the address (mailing address, email, twitter handle, etc.). The send message and display functionality are unique to each derived class, so these were made as pure virtual functions so that the derived classes such as Text and Email have to implement this functionality.  The responsibilities of the classes were not extended to other classes, for example when the CLL data needs to be set, there is a function to set this data within the Person class (which contains the CLL), so that other classes are not trying to access or get this data in order to use or change it. In a larger application, the same hierarchical relationships would work, however the way that they are used may have to change (a larger application may allow for more functionality to combine these basic methods), and data structures used within may have to be modified to work more efficiently in a larger system.

GDB was used here to ensure that run-time segmentation faults or memory leaks would not take place, and that items were destructed properly. One example of where I used GDB was to debug my add() function for the addressbook. I set up a breakpoint at the beginning of the function, and used the Next and Step commands to execute the next line of code and enter function calls (constructor function call for when a new node was created in the base case). When the program ran into the segmentation fault, I searched the backtrace for when the segmentation fault occured, to see where in the call stack the segmentation fault had occured. I found that even when there was a node in the list, it would enter the first condition of an empty tree. I was able to change the entering condition to fix the wrror. In order to detect any memory leaks, valgrind was used to check if there were any memory losses. 

If I had more time, I would like to try exploring how to write the addressbook data into a file to effectively save the addressbook, which would allow the program to be more easily testible. By reading and writing from a file, the existing contacts are saved and the program can be used to implement/test sending and receiving messages more easily. I also would like to implement the case for having all contacts with the same name enter a dynamic array with a different data structure (like a linked list), as the program has to traverse the array anyway to find the contact match, so direct access of the array is not being used. Using the array only is a constraint, as it makes the max number of people with the same name a fixed number. The design could be improved to make a user class that is derived from Person, so that the Person functionality is available to the User, but in a more specialized way. This improves the OO design because in a real-life implementation, the user is a person, but has additional features that a regular Person in the addressbook has, such as sending messages or checking their messages.