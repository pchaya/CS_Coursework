Prathyoosha Chaya, CS 163 DATA STRUCTURES, Prof. Karla Fant
Efficiency Review 5
The overlying abstract data type used in this program was a graph. In this scenario, a graph ADT is definitely the right choice to make in creating the map of the FAB building in use here – as there is no efficient way to make a data structure with so many interconnected pieces of data in a regular tree or table. The adjacency list creates a situation where there can potentially be "holes' in the data for the vertices, making this an "absolute list" of sorts. As the dictionary can have "holes" in the data, and if an vertex (location name and pointer to head of edge list) is removed from the tree or added, it is not relative to other nodes, and they should not shift around to accomodate in any way. The location of the vertex in the array is crucial to maintain the order of the graph, as if the vertex locations change, then the edge list pointers to these vertices would also have to change. The underlying data structures used were a struct entry type to create the vertex classification along with the node structure. The node structure has an instance within the vertex structure, as each seperate vertex will have it's own "head" pointer to a list of other vertices that it is connected to. These connections are shown through a linked list, where each node has the pointer to a vertex, along with a node-type pointer to the next connection, which acts as the edge. Conceptually, the idea of having the underlying data form structures made sense. The data types could be easily grouped together and is easily accessible by the node class. By having the entry data and node as separate classes, the construction and destruction of these objects could be neatly managed.

A new vertex is inserted into the adjacency list in a way that could be potentially more efficient. Currently, the insert program loops through the adjacency list until it finds a vertex slot that is empty (the name pointer in the vertex is null). It then proceeds to add the data into that slot by calling a "set vertex" data function. If a counter was kept at the number of items that are currently in the adjacency list as a private member to the graph class, then the data item could be just added to the adjacency list's index at the counter + 1, given that counter + 1 is within the bounds of the adjacency list. While it seems insignificant for my current adjacency list which only has a max number of 10 vertices, for large datasets with many vertices (such as a map of the city of Portland), this would prove to be extremely inefficient when we should be taking advantage of an array's direct access by using a counter, instead of traversing through everything to find a spot that isn't empty, when they are all inserted into the next empty space anyway. Since this is an undirected graph (we can walk from a classroom in the FAB building to a water fountain, then walk back without it being a one-way path), the insert edge algorithm requires the connection between the items to be made on both vertices. This will double the work that needs to be done to add an edge, but since these are added directly to head (beginning of edge list), it does not lower efficiency too much for the functionality it provides.

If I had more time, I would like to try exploring how to load the data for the graph from a file, which would be a challenge to implement and register all of the proper connections. I would also like to see what other implementations of a graph can be used besides an adjacency list, and potentially add other functionality, such as displaying the shortest path to take from one point to another in the FAB building.