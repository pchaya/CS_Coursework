Prathyoosha Chaya, CS 163 DATA STRUCTURES, Prof. Karla Fant
Efficiency Review 2
The overlying abstract data type used in this program was a relative singly linked list, and an absolute linked list of arrays to act as a stack. In this scenario, a relative list is definitely the right choice to make in creating the initial list of cards – allowing the cards to shift without creating holes if a card is removed from the deck or added, relative to other members. The underlying data structures used were a struct card type to create the data classification within the node and to allow the application to have its own user-filled card to communicate to the ADT, as well as a struct node type. Conceptually, the idea of having the underlying data form structures made sense. The data types could be easily grouped together and is easily accessible by the node class. By having the card data and node as separate classes, the construction and destruction of these objects could be neatly managed.
To store the data about the deck of cards initially before randomizing and pushing into a stack, a linear linked list was used. An array would have allowed for easy access and to avoid traversals when displaying the values and creating the array of pointers, but it would have required us to either know beforehand how many cards we would have in the deck, or put a restriction on it. With a linked list, the cards can be easily added to the head and removed without any traversal, providing an efficient O(1) adding and removing process. 
A linked list of arrays is used to function as a stack once the game is played. The benefit of this is a large increase in efficiency, because there is no need to traverse in this case. All of the stack functions (such as is_empty, pop, push, and display) are O(1), because only the first item is accessed at any point in time. However, a different data structure, such as a linked list, would have been more efficient. Since efficiency is a matter of memory and not runtime efficiency in this case (because there is no traversal and runtime efficiency would be nearly the same for an array vs. linked list), a linked list of arrays, like the one implemented in this program, could result in more memory usage than a regular singly linked list. This is because if the array elements of any node are not filled up completely, then that memory is being wasted. However, for a linked list, any card that is deleted will not have its corresponding node in the list anymore. This would give the same problem for using a regular array, and a regular array should not be used as a stack implementation anyway because of rightward drift that will occur upon removal of cards.
The parts that were the most efficient were the functions manipulating the stack, as there was no traversal necessary. The major efficiency losses in this program were through the areas where full traversal of the list was necessary, such as when reading from the file into the LLL, writing the LLL back to the file, and displaying the LLL of cards. 
If I had more time, I would like to try exploring how to implement a similar design with different data structures, and finding how to get around some of the limitations of certain data structures. I would also like to add more functionality to the game playing, like scoring, categorizing the cards by right answers/wrong answers, and getting the user’s input while playing the game.
